#define _USE_MATH_DEFINES
#include "quadric.h"
#include <cmath>
#include <iostream>
//==============================================================================
namespace cg {
//==============================================================================
Quadric::Quadric(const mat4& _A, const Material& m)
    : Renderable{m}, A{_A} {}
//------------------------------------------------------------------------------
Quadric::Quadric(const mat3& _A, const vec3& b, double c, const Material& m)
    : Renderable{m}, A{mat4::zeros()} {
  for (size_t r = 0; r < 3; ++r) {
    for (size_t c = 0; c < 3; ++c) { A(c, r) = _A(c, r); }
  }
  for (size_t i = 0; i < 3; ++i) { A(3, i) = A(i, 3) = b(i); }
  A(3, 3) = c;
  std::cerr << A << '\n';
}
//------------------------------------------------------------------------------
std::optional<std::pair<double, double>> Quadric::solve_quadratic(
    const Ray& r) const {
  const auto& d = r.direction();
  const auto& y = r.origin();

  double discriminant =
      (-(d(2) * d(2)) * A(2, 2) - 2 * d(1) * d(2) * A(2, 1) -
       2 * d(0) * d(2) * A(2, 0) - (d(1) * d(1)) * A(1, 1) -
       2 * d(0) * d(1) * A(1, 0) - (d(0) * d(0)) * A(0, 0)) *
          A(3, 3) +
      ((-(d(1) * d(1)) * (y(2) * y(2)) + 2 * d(1) * y(1) * d(2) * y(2) -
        (y(1) * y(1)) * (d(2) * d(2))) *
           A(1, 1) +
       (-2 * d(0) * d(1) * (y(2) * y(2)) +
        (2 * d(0) * y(1) + 2 * y(0) * d(1)) * d(2) * y(2) -
        2 * y(0) * y(1) * (d(2) * d(2))) *
           A(1, 0) +
       (-(d(0) * d(0)) * (y(2) * y(2)) + 2 * d(0) * y(0) * d(2) * y(2) -
        (y(0) * y(0)) * (d(2) * d(2))) *
           A(0, 0) +
       (2 * A(1, 3) * d(1) + 2 * A(0, 3) * d(0)) * d(2) * y(2) +
       (-2 * A(1, 3) * y(1) - 2 * A(0, 3) * y(0)) * (d(2) * d(2))) *
          A(2, 2) +
      ((d(1) * d(1)) * (y(2) * y(2)) - 2 * d(1) * y(1) * d(2) * y(2) +
       (y(1) * y(1)) * (d(2) * d(2))) *
          (A(2, 1) * A(2, 1)) +
      ((2 * d(0) * d(1) * (y(2) * y(2)) +
        (-2 * d(0) * y(1) - 2 * y(0) * d(1)) * d(2) * y(2) +
        2 * y(0) * y(1) * (d(2) * d(2))) *
           A(2, 0) +
       ((2 * y(0) * (d(1) * d(1)) - 2 * d(0) * d(1) * y(1)) * y(2) +
        (2 * d(0) * (y(1) * y(1)) - 2 * y(0) * d(1) * y(1)) * d(2)) *
           A(1, 0) +
       ((2 * d(0) * y(0) * d(1) - 2 * (d(0) * d(0)) * y(1)) * y(2) +
        (2 * d(0) * y(0) * y(1) - 2 * (y(0) * y(0)) * d(1)) * d(2)) *
           A(0, 0) +
       (-2 * d(1) * A(2, 3) * d(2) + 2 * A(1, 3) * (d(1) * d(1)) +
        2 * A(0, 3) * d(0) * d(1)) *
           y(2) +
       2 * y(1) * A(2, 3) * (d(2) * d(2)) +
       ((2 * A(0, 3) * d(0) - 2 * A(1, 3) * d(1)) * y(1) -
        4 * A(0, 3) * y(0) * d(1)) *
           d(2)) *
          A(2, 1) +
      ((d(0) * d(0)) * (y(2) * y(2)) - 2 * d(0) * y(0) * d(2) * y(2) +
       (y(0) * y(0)) * (d(2) * d(2))) *
          (A(2, 0) * A(2, 0)) +
      (((2 * d(0) * d(1) * y(1) - 2 * y(0) * (d(1) * d(1))) * y(2) +
        (2 * y(0) * d(1) * y(1) - 2 * d(0) * (y(1) * y(1))) * d(2)) *
           A(1, 1) +
       ((2 * (d(0) * d(0)) * y(1) - 2 * d(0) * y(0) * d(1)) * y(2) +
        (2 * (y(0) * y(0)) * d(1) - 2 * d(0) * y(0) * y(1)) * d(2)) *
           A(1, 0) +
       (-2 * d(0) * A(2, 3) * d(2) + 2 * d(0) * A(1, 3) * d(1) +
        2 * A(0, 3) * (d(0) * d(0))) *
           y(2) +
       2 * y(0) * A(2, 3) * (d(2) * d(2)) +
       (-4 * d(0) * A(1, 3) * y(1) + 2 * y(0) * A(1, 3) * d(1) -
        2 * A(0, 3) * d(0) * y(0)) *
           d(2)) *
          A(2, 0) +
      ((-(d(0) * d(0)) * (y(1) * y(1)) + 2 * d(0) * y(0) * d(1) * y(1) -
        (y(0) * y(0)) * (d(1) * d(1))) *
           A(0, 0) -
       2 * (d(1) * d(1)) * A(2, 3) * y(2) + 2 * d(1) * y(1) * A(2, 3) * d(2) +
       2 * A(0, 3) * d(0) * d(1) * y(1) - 2 * A(0, 3) * y(0) * (d(1) * d(1))) *
          A(1, 1) +
      ((d(0) * d(0)) * (y(1) * y(1)) - 2 * d(0) * y(0) * d(1) * y(1) +
       (y(0) * y(0)) * (d(1) * d(1))) *
          (A(1, 0) * A(1, 0)) +
      (-4 * d(0) * d(1) * A(2, 3) * y(2) +
       (2 * d(0) * y(1) + 2 * y(0) * d(1)) * A(2, 3) * d(2) +
       (2 * A(0, 3) * (d(0) * d(0)) - 2 * d(0) * A(1, 3) * d(1)) * y(1) +
       2 * y(0) * A(1, 3) * (d(1) * d(1)) - 2 * A(0, 3) * d(0) * y(0) * d(1)) *
          A(1, 0) +
      (-2 * (d(0) * d(0)) * A(2, 3) * y(2) + 2 * d(0) * y(0) * A(2, 3) * d(2) -
       2 * (d(0) * d(0)) * A(1, 3) * y(1) + 2 * d(0) * y(0) * A(1, 3) * d(1)) *
          A(0, 0) +
      (A(2, 3) * A(2, 3)) * (d(2) * d(2)) +
      (2 * A(1, 3) * d(1) + 2 * A(0, 3) * d(0)) * A(2, 3) * d(2) +
      (A(1, 3) * A(1, 3)) * (d(1) * d(1)) +
      2 * A(0, 3) * d(0) * A(1, 3) * d(1) + (A(0, 3) * A(0, 3)) * (d(0) * d(0));

  if (discriminant < 0) { return {}; }

  double sqrt_discriminant = std::sqrt(discriminant);

  double t1 = -(sqrt_discriminant + d(2) * y(2) * A(2, 2) +
                (d(1) * y(2) + y(1) * d(2)) * A(2, 1) +
                (d(0) * y(2) + y(0) * d(2)) * A(2, 0) + d(1) * y(1) * A(1, 1) +
                (d(0) * y(1) + y(0) * d(1)) * A(1, 0) + d(0) * y(0) * A(0, 0) +
                A(3, 2) * d(2) + A(3, 1) * d(1) + A(3, 0) * d(0)) /
              ((d(2) * d(2)) * A(2, 2) + 2 * d(1) * d(2) * A(2, 1) +
               2 * d(0) * d(2) * A(2, 0) + (d(1) * d(1)) * A(1, 1) +
               2 * d(0) * d(1) * A(1, 0) + (d(0) * d(0)) * A(0, 0));

  double t2 = (sqrt_discriminant - d(2) * y(2) * A(2, 2) +
               (-d(1) * y(2) - y(1) * d(2)) * A(2, 1) +
               (-d(0) * y(2) - y(0) * d(2)) * A(2, 0) - d(1) * y(1) * A(1, 1) +
               (-d(0) * y(1) - y(0) * d(1)) * A(1, 0) - d(0) * y(0) * A(0, 0) -
               A(3, 2) * d(2) - A(3, 1) * d(1) - A(3, 0) * d(0)) /
              ((d(2) * d(2)) * A(2, 2) + 2 * d(1) * d(2) * A(2, 1) +
               2 * d(0) * d(2) * A(2, 0) + (d(1) * d(1)) * A(1, 1) +
               2 * d(0) * d(1) * A(1, 0) + (d(0) * d(0)) * A(0, 0));

  return std::pair{t1, t2};
}
//------------------------------------------------------------------------------
std::optional<Intersection> Quadric::check_intersection(const Ray& r,
                                                        double min_t) const {
  auto solutions = solve_quadratic(r);
  if (!solutions) { return {}; }

  const auto& [t0, t1] = *solutions;
  if (t0 < min_t && t1 < min_t) { return {}; }

  double t;
  if (t1 < 0) {
    t = t0;
  } else if (t0 < 0) {
    t = t1;
  } else if (t0 < t1) {
    t = t0 > min_t ? t0 : t1;
  } else {
    t = t1 > min_t ? t1 : t0;
  }

  const auto x = r(t);

  // clipping
  for (auto c : x) {
    if (c < -1.5 || c > 1.5) { return {}; }
  }
  const vec3 n{A(0, 0) * x(0) + A(0, 1) * x(1) + A(0, 2) * x(2) + A(0, 3),
               A(1, 0) * x(0) + A(1, 1) * x(1) + A(1, 2) * x(2) + A(1, 3),
               A(2, 0) * x(0) + A(2, 1) * x(1) + A(2, 2) * x(2) + A(2, 3)};

  return Intersection{this, r, t, x, normalize(n), vec2::zeros()};
}
//==============================================================================
}  // namespace cg
//==============================================================================
